import json
from all_commands import return_command
from json_builder import add_action_RLE_json
from utils import *

from textx import metamodel_from_file

rle_mm = metamodel_from_file('rle.tx')
rle_model = rle_mm.model_from_file('input.rbt')





class Program(object):
    def __init__(self):
        self.actions = []

    def __str__(self):
        return f"Program is loading..."

    def interpret(self, model):

        # model is an instance of Program
        f = open("Input/commands.json")
        try:
            data = json.load(f)
        except:
            print("Command json is empty")

        # Prints available actions and commands associated
        # for action in data['actions']:
        #     print(action['action_name'])
        #     print(return_command(action['action_name']))

        for c in model.commands:
            if c.__class__.__name__ == "EXECUTE_ORDER":
                words = c.target
                # TODO Replace steps with value of True or False

                # print(eval(words))
                # print(words)

        for s in model.steps:
            print(s.id, s.command.__class__.__name__, s.command.target, s.command.expect)
            #cmd = return_command(s.command.__class__.__name__, s.command.target)
            #print(cmd)
            add_action_RLE_json(s.id, s.command.__class__.__name__, s.command.target, s.command.expect)
            #TODO CALL JSON BUILDER HERE CUZ OTHERWISE
            # write_to_script(cmd)


if __name__ == '__main__':
    runPythonAsAdmin()
    runPowershellScript()

    # Read input file and parse through DSL
    program = Program()
    program.interpret(rle_model)
