import ctypes
import json
import os
import subprocess
import sys
from Input.all_commands import return_command

from textx import metamodel_from_file

rle_mm = metamodel_from_file('rle.tx')
rle_model = rle_mm.model_from_file('input.rbt')


def write_to_script(string_to_write):
    f = open(path_to_script, "w")
    f.write("Set-ExecutionPolicy RemoteSigned\n")
    f.write(string_to_write + "> \".\\output.tmp\"\n")
    f.write("Exit\n")
    f.write("Set-ExecutionPolicy Restricted\n")

    f.close()


# MUST CREATE DICTIONARY OF POSSIBLE COMMANDS AND PARAMETERS
def check_output(target, action):
    # TODO for each action, check output accordingly
    f = open(path_to_script, "r")


def get_path_to_script():
    current_dir = os.getcwd()
    return str(current_dir + "\script.ps1")


def get_path_to_output():
    current_dir = os.getcwd()
    return str(current_dir + "\output.tmp")


path_to_script = get_path_to_script()
path_to_output = get_path_to_output()


# Run python script as administrator
def runPythonAsAdmin():
    def is_admin():
        try:
            return ctypes.windll.shell32.IsUserAnAdmin()
        except:
            return False

    if is_admin():
        runPowershellScript()
    else:
        # Re-run the program with admin rights
        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)


# Run the script
def runPowershellScript():
    # This will run as admin if runPythonAsAdmin is successful
    # print(path_to_script)
    psResult = subprocess.Popen([r'powershell.exe',
                                 '-ExecutionPolicy',
                                 'Unrestricted',
                                 path_to_script,
                                 ],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
    psResult.communicate()


class Program(object):
    def __init__(self):
        self.actions = []

    def __str__(self):
        return f"Program is loading..."

    def interpret(self, model):

        # model is an instance of Program
        f = open("Input/commands.json")
        data = json.load(f)

        # Prints available actions and commands associated
        for action in data['actions']:
            print(action['action_name'])
            print(action['action_parameters']['command'])
            # for parameter in action['action_parameters']:
            #     print(parameter['command'])

        for c in model.commands:
            if c.__class__.__name__ == "EXECUTE_ORDER":
                words = c.target
                # TODO Replace steps with value of True or False

                # print(eval(words))
                print(words)

        for s in model.steps:
            print(s.id, s.command.__class__.__name__, s.command.target, s.command.expected_version)
            version_cmd = return_command(s.command.__class__.__name__, s.command.target)
            print(version_cmd)
        #     write_to_script(version_cmd)


if __name__ == '__main__':
    runPythonAsAdmin()
    runPowershellScript()

    # Read input file and parse through DSL
    program = Program()
    program.interpret(rle_model)
