import ctypes
import itertools
import json
import os
import subprocess
import sys
import time
from tabulate import tabulate
import paths


def check_output(json_filename):
    print("Checking Output")

    with open(paths.expected_output_path, "r") as file:
        exp_data = file.read().splitlines()

    with open(paths.script_output_path, "r") as file:
        out_data = file.read().splitlines()

    step_id = 1
    results = []
    # Column headers
    table = [['Step ID', 'Expected', 'Received', 'Result']]

    # Interleave both lists
    for (i, j) in itertools.zip_longest(exp_data, out_data):
        result = 'False'
        # If result is better than expected (higher/greater) the result is True
        if j >= i:
            result = 'True'
        table.append([step_id, i, j, result])
        results.append(result)
        step_id += 1

    with open(paths.final_path, "a") as final:
        final.write(tabulate(table, headers='firstrow', tablefmt='pretty'))

    # Prepare to refresh 'final_bool' in commands.json
    f = open(json_filename, "r")
    data = json.load(f)

    for step in range(step_id - 1):
        data['actions'][step]['final_bool'] = results[step]

    with open(json_filename, "w") as outfile:
        outfile.write(json.dumps(data, indent=4))

    print("Done Checking Output")


def write_powershell_prefix(filename):
    with open(filename, 'a') as f:
        f.write("Set-ExecutionPolicy RemoteSigned\n")


def write_powershell_suffix(filename):
    with open(filename, 'a') as f:
        f.write("Exit\n")
        f.write("Set-ExecutionPolicy Restricted\n")


def write_to_script(filename, string_to_write, step_id, command):
    arg_string = "$step_" + str(step_id)
    with open(filename, 'a') as f:
        f.write(arg_string + " = " + "$null;\n")
        f.write(arg_string + " = " + string_to_write + '\n')

        # True Branch
        f.write("If (" + arg_string + " -ne $null)\n{\n")
        if command == "CHECK_VERSION":
            f.write(arg_string + " | Add-Content \".\\Output\\output.txt\"\n")
        elif command == "READ_REGISTRY":
            f.write("echo True" + " | Add-Content \".\\Output\\output.txt\"\n")
        else:
            f.write(string_to_write + " | Add-Content \".\\Output\\output.txt\"\n")
        # False Branch
        f.write("}\nElse\n{\n")
        if command == "CHECK_VERSION":
            f.write("echo null | Add-Content \".\\Output\\output.txt\"\n}\n\n")
        elif command == "READ_REGISTRY":
            f.write("echo False | Add-Content \".\\Output\\output.txt\"\n}\n\n")
        else:
            f.write("echo False" + " | Add-Content \".\\Output\\output.txt\"\n}\n\n")


def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False


def replace_steps_with_value(total_steps, feasibility_formula, value_path):
    with open(value_path) as f:
        data = json.load(f)

    steps_values = {}
    for i in range(total_steps):
        steps_values[i] = data['actions'][i]['final_bool']

    replaced = feasibility_formula
    for i in range(1, total_steps + 1):
        step = '{s' + str(i) + '}'
        replaced = replaced.replace(step, steps_values[i - 1])
        # print(replaced)

    # Adding evaluation details to commands.json
    evaluated = str(eval(replaced))
    final_verdict = ("Exploitable" if evaluated == 'False' else "Not exploitable")
    data['evaluation'] = {
        "feasibility_formula": feasibility_formula,
        "replaced": replaced,
        "evaluated": evaluated,
        "final_verdict": final_verdict
    }

    with open(value_path, "w") as outfile:
        outfile.write(json.dumps(data, indent=4))
    # except NameError:
    #     print("***Problem parsing Feasibility formula | Check all step names***")


# Run python script as administrator
def runPythonAsAdmin(total_steps, feasibility_formula, ps1_filename, json_filename):
    if is_admin():
        print("Running as Admin")
        time.sleep(1)
        print("Running powershell script")
        print(ps1_filename)
        runPowershellScript(ps1_filename)
        print("Done running script")
        check_output(json_filename)
        replace_steps_with_value(total_steps, feasibility_formula, json_filename)
        print("Done adding final results. Check json and final.txt !")
    else:
        # Re-run the program with admin rights
        ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)


def write_expected_output(json_filename):
    # Write file to be checked against powershell script output
    try:
        with open(json_filename, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        print("@write_expected_output -- Json file cannot be found !")
    else:
        for item in data['actions']:
            with open(paths.expected_output_path, 'a') as fs:
                fs.write(item["value_expected"] + '\n')


# Run the script
def runPowershellScript(ps1_filename):
    # This will run as admin if runPythonAsAdmin is successful
    psResult = subprocess.Popen([r'powershell.exe',
                                 '-ExecutionPolicy',
                                 'Unrestricted',
                                 ps1_filename,
                                 ],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
    psResult.communicate()


def cleanup_files(path):
    if os.path.exists(path):
        os.remove(path)
    f = open(path, "w+")
    f.close()
