import logging
import shutil

from textx import metamodel_from_file, TextXSyntaxError

import paths
from all_commands import return_command
from json_builder import add_action_RLE_json
from utils import *

total_steps = 0
feasibility_formula = ""
run_script = False
ps1_filename = ""
json_filename = ""


def interpret(model):
    # model is an instance of Program

    # If "run" command is issued, make sure to search for the script and run it
    if model.__class__.__name__ == 'RunFile':
        """ What happens when requested to run script
                    1. Run ps script and go straight to checking output and update json
                    2. Run from json and update it 
                    ???
        """

        logging.info("Running " + model.filename)
        global run_script
        run_script = True

        # TODO directory
        global ps1_filename, json_filename
        ps1_filename = paths.scripts_path + model.filename + ".ps1"
        json_filename = paths.scripts_path + model.filename + ".json"
        print(ps1_filename)
        # On each new run, rebuild commands + output + script file
        cleanup_files(path=paths.expected_output_path)
        cleanup_files(path=paths.script_output_path)
        cleanup_files(path=paths.final_path)
        # Write file to be checked against powershell script output
        write_expected_output(json_filename=json_filename)

    else:

        global feasibility_formula
        feasibility_formula = model.formula
        global total_steps
        total_steps = model.number

        # Create directory for new vulnerability
        cve_filename = paths.scripts_path + model.filename + "\\"
        try:
            os.mkdir(cve_filename)
        except OSError as error:
            logging.info("Directory already exists - Overwriting")

        ps1_filename = cve_filename + model.filename + ".ps1"
        json_filename = cve_filename + model.filename + ".json"
        dsl_filename = cve_filename + model.filename + ".txt"

        # On each new run, rebuild commands + output + script file
        cleanup_files(path=json_filename)
        cleanup_files(path=ps1_filename)
        cleanup_files(path=dsl_filename)
        cleanup_files(path=paths.final_path)
        cleanup_files(path=paths.expected_output_path)
        cleanup_files(path=paths.script_output_path)
        cleanup_files(dsl_filename)
        shutil.copyfile(paths.input_path, dsl_filename)
        print(paths.input_path, dsl_filename)


        # Write powershell script
        write_powershell_prefix(ps1_filename)
        step_id = 0
        for s in model.steps:
            step_id += 1

            """ 
                What? There's no target ? example: get_windows_version needs only expect
                try-except + optional args in return_command and add_action_RLE_json
            """
            try:
                cmd = return_command(s.command.__class__.__name__, s.command.target)
                add_action_RLE_json(json_filename, step_id, s.command.__class__.__name__, cmd,
                                    s.command.expect, s.command.target)
            except AttributeError:
                cmd = return_command(s.command.__class__.__name__)
                add_action_RLE_json(json_filename, step_id, s.command.__class__.__name__, cmd,
                                    s.command.expect)

            write_to_script(ps1_filename, string_to_write=cmd, step_id=step_id, command=s.command.__class__.__name__)
        write_powershell_suffix(ps1_filename)

        # Error checking - exit if number of steps with steps provided differs
        if step_id != total_steps:
            logging.exception("Wrong number of steps!")
            sys.exit()

        # Write file to be checked against powershell script output
        write_expected_output(json_filename=json_filename)

        # Save additional info in json file
        with open(json_filename, "r") as temp:
            json_data = json.load(temp)

        json_data['additional_info'] = {
            "total_steps": total_steps,
            "feasibility_formula": feasibility_formula
        }

        with open(json_filename, "w") as outfile:
            outfile.write(json.dumps(json_data, indent=4))

        logging.info("Saving " + model.filename)
        time.sleep(1)





class Program(object):
    def __init__(self):
        self.actions = []

    def __str__(self):
        return f"Program is loading..."


if __name__ == '__main__':
    cleanup_files(path=paths.log_path)
    # Remove all handlers associated with the root logger object.
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    logging.getLogger().setLevel(logging.INFO)
    logging.basicConfig(filename='.\\Output\\out.log', filemode='w', level=logging.INFO)

    # ADD DEBUG OPTION
    sys.tracebacklimit = 1

    logging.info("Starting Checker...")
    if not is_admin():
        logging.warning("Not Admin")
    else:
        rle_mm = metamodel_from_file('rle.tx')
        try:
            rle_model = rle_mm.model_from_file('.//Input//input.txt')
        except TextXSyntaxError as e:
            logging.exception(e)
        else:
            # Read input file and parse through DSL
            program = Program()
            interpret(rle_model)
            try:
                with open(json_filename, "r") as f:
                    data = json.load(f)
            except FileNotFoundError:
                logging.exception("@main-- Json file cannot be found !")
            else:
                runPythonAsAdmin(data['additional_info']['total_steps'], data['additional_info']['feasibility_formula'],
                                 ps1_filename, json_filename)
