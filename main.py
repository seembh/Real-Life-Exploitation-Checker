from all_commands import return_command
from json_builder import add_action_RLE_json
from utils import *
from textx import metamodel_from_file

rle_mm = metamodel_from_file('rle.tx')
rle_model = rle_mm.model_from_file('.//Input//input.rbt')

total_steps = 0
feasibility_formula = ""


class Program(object):
    def __init__(self):
        self.actions = []

    def __str__(self):
        return f"Program is loading..."

    def interpret(self, model):
        # model is an instance of Program

        # Prints available actions and commands associated
        # for action in data['actions']:
        #     print(action['action_name'])
        #     print(return_command(action['action_name']))

        for c in model.commands:
            if c.__class__.__name__ == "EXECUTE_ORDER":
                global feasibility_formula
                feasibility_formula = c.target

        global total_steps
        total_steps = model.number
        # Write powershell script
        write_powershell_prefix()
        for s in model.steps:
            # Write file to be checked against powershell script output
            with open('Output/expected_output.tmp', 'a') as fs:
                fs.write(s.command.expect + '\n')
            cmd = return_command(s.command.__class__.__name__, s.command.target)
            add_action_RLE_json(s.id, s.command.__class__.__name__, s.command.target, cmd, s.command.expect)
            write_to_script(string_to_write=cmd, step_id=s.id, command=s.command.__class__.__name__)
        write_powershell_suffix()


if __name__ == '__main__':
    print("Starting Checker...")
    if not is_admin():
        print("Not Admin")
    else:
        # On each new run, rebuild commands + output + script file
        cleanup_files()

        # Read input file and parse through DSL
        program = Program()
        program.interpret(rle_model)
        runPythonAsAdmin(total_steps, feasibility_formula)

